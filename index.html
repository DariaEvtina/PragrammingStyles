<html>
  <head>
    <title>SDLC</title>
  </head>
<!--What is  a ADLC Software Development Life Cycle (SDLC)
MVC - modal view controler-->
<body>
<style>
  h1{
    background-color: #eee;
    color: #444;
  }
  p{
    color: #444;
  }
.accordion {
  background-color: #eee;
  color: #444;
  cursor: pointer;
  padding: 18px;
  width: 100%;
  border: none;
  text-align: left;
  outline: none;
  font-size: 15px;
  transition: 0.4s;
}

.active, .accordion:hover {
  background-color: #ccc; 
}

.panel {
  padding: 0 18px;
  display: none;
  background-color: white;
  overflow: hidden;
}
</style>
<h1>Programming Styles (Large-scale)</h1>
<button class="accordion">Imperative</button>
<div class="panel">
  <p>In computer science, imperative programming is a programming paradigm that uses statements that change a program's state. In much the same way that the imperative mood in natural languages expresses commands, an imperative program consists of commands for the computer to perform.</p>
</div>

<button class="accordion">Logical</button>
<div class="panel">
  <p>Logic programming is a programming paradigm which is largely based on formal logic. Any program written in a logic programming language is a set of sentences in logical form, expressing facts and rules about some problem domain. Major logic programming language families include Prolog, answer set programming (ASP) and Datalog. In all of these languages, rules are written in the form of clauses:

    H :- B1, …, Bn.

and are read declaratively as logical implications:

    H if B1 and … and Bn.

H is called the head of the rule and B1, ..., Bn is called the body. Facts are rules that have no body, and are written in the simplified form:

    H.

In the simplest case in which H, B1, ..., Bn are all atomic formulae, these clauses are called definite clauses or Horn clauses. However, there are many extensions of this simple case, the most important one being the case in which conditions in the body of a clause can also be negations of atomic formulas. Logic programming languages that include this extension have the knowledge representation capabilities of a non-monotonic logic. </p>
</div>

<button class="accordion">Functional.</button>
<div class="panel">
  <p>Functional programming is a programming paradigm in which we try to bind everything in pure mathematical functions style. It is a declarative type of programming style. Its main focus is on “what to solve” in contrast to an imperative style where the main focus is “how to solve”.</p>
</div>
<button class="accordion">Object-Oriented.</button>
<div class="panel">
  <p>Object Oriented programming is a programming style which is associated with the concepts like class, object, Inheritance, Encapsulation, Abstraction, Polymorphism. Most popular programming languages like Java, C++, C#, Ruby, etc. follow an object-oriented programming paradigm.</p>
</div>
<button class="accordion">Behavior-driven development</button>
<div class="panel">
  <p>In software engineering, behavior-driven development (BDD) is an agile software development process that encourages collaboration among developers, quality assurance testers, and customer representatives in a software project. It encourages teams to use conversation and concrete examples to formalize a shared understanding of how the application should behave.[4] It emerged from test-driven development (TDD). Behavior-driven development combines the general techniques and principles of TDD with ideas from domain-driven design and object-oriented analysis and design to provide software development and management teams with shared tools and a shared process to collaborate on software development.

Although BDD is principally an idea about how software development should be managed by both business interests and technical insight, the practice of BDD does assume the use of specialized software tools to support the development process. Although these tools are often developed specifically for use in BDD projects, they can be seen as specialized forms of the tooling that supports test-driven development. The tools serve to add automation to the ubiquitous language that is a central theme of BDD.

BDD is largely facilitated through the use of a simple domain-specific language (DSL) using natural-language constructs (e.g., English-like sentences) that can express the behaviour and the expected outcomes. Test scripts have long been a popular application of DSLs with varying degrees of sophistication. BDD is considered an effective technical practice especially when the "problem space" of the business problem to solve is complex.</p>
</div>
  <button class="accordion">Design-driven development</button>
<div class="panel">
  <p>What is Design-Driven Development?

Design driven development uses design as part of a process to learn and better define requirements in order to build better, more informed technology solutions. It can also be looked at as a process whereby design and user experience drives the development of a product or software application. This leads to products that people enjoy using and want to tell others about.
A Design Driven Development Scenario

The Problem + Solutions Thinking Your team has identified a customer problem. You quickly take a divergent approach to brainstorming as a small, diverse group spanning product management, design, technology and sales — to come up with different ideas for how to solve the problem. Through group discussion, you identify the three most valuable ideas. Your designer quickly creates a design artefact or clickable prototype OR 1–2 developers creates a quick and dirty coded prototype.

Solutions Testing + Learning You identify a small group of customers and through 3–4 quick rounds of user testing, you learn how to you learn how to improve or change the feature to better meet customer needs.

Product Design Before Development You then take the time you need to thoroughly design the feature with continued customer feedback and internal stakeholder reviews. This creates design definition, and also helps your team flesh out technical requirements along the way all while defining a real scope of work prior to coding.</p>
</div>
  <button class="accordion">Domain-driven design</button>
<div class="panel">
  <p>Domain-driven design (DDD) is a software design approach  focusing on modelling software to match a domain according to input from that domain's experts.

In terms of object-oriented programming it means that the structure and language of software code (class names, class methods, class variables) should match the business domain. For example, if a software processes loan applications, it might have classes like LoanApplication and Customer, and methods such as AcceptOffer and Withdraw.

DDD connects the implementation to an evolving model.

Domain-driven design is predicated on the following goals:

    placing the project's primary focus on the core domain and domain logic;
    basing complex designs on a model of the domain;
    initiating a creative collaboration between technical and domain experts to iteratively refine a conceptual model that addresses particular domain problems.

Criticisms of domain-driven design argue that developers must typically implement a great deal of isolation and encapsulation to maintain the model as a pure and helpful construct. While domain-driven design provides benefits such as maintainability, Microsoft recommends it only for complex domains where the model provides clear benefits in formulating a common understanding of the domain.

The term was coined by Eric Evans in his book of the same title published in 2003.</p>
</div>
  <button class="accordion">Secure by design</button>
<div class="panel">
  <p>Secure by design, in software engineering, means that software products and capabilities have been designed to be foundationally secure.

Alternate security strategies, tactics and patterns are considered at the beginning of a software design, and the best are selected and enforced by the architecture, and they are used as guiding principles for developers.[1] It is also encouraged to use strategic design patterns that have beneficial effects on security, even though those design patterns were not originally devised with security in mind.[2]

Secure by Design is increasingly becoming the mainstream development approach to ensure security and privacy of software systems. In this approach, security is considered and built into the system at every layer and starts with a robust architecture design. Security architectural design decisions are based on well-known security strategies, tactics, and patterns defined as reusable techniques for achieving specific quality concerns. Security tactics/patterns provide solutions for enforcing the necessary authentication, authorization, confidentiality, data integrity, privacy, accountability, availability, safety and non-repudiation requirements, even when the system is under attack.[3] In order to ensure the security of a software system, not only is it important to design a robust intended security architecture but it is also necessary to map updated security strategies, tactics and patterns to software development in order to maintain security persistence. </p>
</div>
  <button class="accordion">Test-driven development</button>
<div class="panel">
  <p>Test-driven development (TDD) is a software development process relying on software requirements being converted to test cases before software is fully developed, and tracking all software development by repeatedly testing the software against all test cases. This is as opposed to software being developed first and test cases created later.

Software engineer Kent Beck, who is credited with having developed or "rediscovered"[1] the technique, stated in 2003 that TDD encourages simple designs and inspires confidence.

Test-driven development is related to the test-first programming concepts of extreme programming, begun in 1999,[3] but more recently has created more general interest in its own right.

Programmers also apply the concept to improving and debugging legacy code developed with older techniques.[</p>
</div>
  <button class="accordion">Acceptance test-driven development</button>
<div class="panel">
  <p>Acceptance test–driven development (ATDD) is a development methodology based on communication between the business customers, the developers, and the testers. ATDD encompasses many of the same practices as specification by example (SBE), behavior-driven development (BDD),example-driven development (EDD) and support-driven development also called story test–driven development (SDD). All these processes aid developers and testers in understanding the customer's needs prior to implementation and allow customers to be able to converse in their own domain language.

ATDD is closely related to test-driven development (TDD). It differs by the emphasis on developer-tester-business customer collaboration. ATDD encompasses acceptance testing, but highlights writing acceptance tests before developers begin coding. </p>
</div>
    <button class="accordion">Continuous test-driven development</button>
<div class="panel">
  <p>Continuous test-driven development (CTDD) is a software development practice that extends test-driven development (TDD) by means of automatic test execution in the background, sometimes called continuous testing. In CTDD the developer writes a test first but is not forced to execute the tests manually. The tests are run automatically by a continuous testing tool running in the background. This technique can potentially reduce the time waste resulting from manual test execution by eliminating the need for the developer to start the test after each phase of the normal TDD practice: after writing the (initially failing) test, after producing the minimal amount of code for the test to pass and after refactoring the code. </p>
</div>
<button class="accordion">Specification by example</button>
  <div class="panel">
  <p>Specification by example (SBE) is a collaborative approach to defining requirements and business-oriented functional tests for software products based on capturing and illustrating requirements using realistic examples instead of abstract statements. It is applied in the context of agile software development methods, in particular behavior-driven development. This approach is particularly successful for managing requirements and functional tests on large-scale projects of significant domain and organisational complexity.

Specification by example is also known as example-driven development, executable requirements, acceptance test–driven development (ATDD or A-TDD), Agile Acceptance Testing, Test-Driven Requirements (TDR). </p>
</div>
  <button class="accordion">Data-driven development</button>
  <div class="panel">
  <p>In computer programming, data-driven programming is a programming paradigm in which the program statements describe the data to be matched and the processing required rather than defining a sequence of steps to be taken. Standard examples of data-driven languages are the text-processing languages sed and AWK, where the data is a sequence of lines in an input stream – these are thus also known as line-oriented languages – and pattern matching is primarily done via regular expressions or line numbers.
ContentsData-driven programming is similar to event-driven programming, in that both are structured as pattern matching and resulting processing, and are usually implemented by a main loop, though they are typically applied to different domains. The condition/action model is also similar to aspect-oriented programming, where when a join point (condition) is reached, a pointcut (action) is executed. A similar paradigm is used in some tracing frameworks such as DTrace, where one lists probes (instrumentation points) and associated actions, which execute when the condition is satisfied.

Adapting abstract data type design methods to object-oriented programming results in a data-driven design. This type of design is sometimes used in object-oriented programming to define classes during the conception of a piece of software. </p>
</div>
<script>
var acc = document.getElementsByClassName("accordion");
var i;

for (i = 0; i < acc.length; i++) {
  acc[i].addEventListener("click", function() {
    this.classList.toggle("active");
    var panel = this.nextElementSibling;
    if (panel.style.display === "block") {
      panel.style.display = "none";
    } else {
      panel.style.display = "block";
    }
  });
}
</script>
</body>
</html>
